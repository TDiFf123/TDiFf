{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.select.html#polars.DataFrame.select"], "Title": ["DataFrame.select"], "Feature": ["DataFrame.select"], "Description": ["Select columns from this DataFrame."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6, 7, 8],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n>>> df.select(\"foo\")\nshape: (3, 1)\n┌─────┐\n│ foo │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n│ 3   │\n└─────┘", ">>> df.select([\"foo\", \"bar\"])\nshape: (3, 2)\n┌─────┬─────┐\n│ foo ┆ bar │\n│ --- ┆ --- │\n│ i64 ┆ i64 │\n╞═════╪═════╡\n│ 1   ┆ 6   │\n│ 2   ┆ 7   │\n│ 3   ┆ 8   │\n└─────┴─────┘", ">>> df.select(pl.col(\"foo\"), pl.col(\"bar\") + 1)\nshape: (3, 2)\n┌─────┬─────┐\n│ foo ┆ bar │\n│ --- ┆ --- │\n│ i64 ┆ i64 │\n╞═════╪═════╡\n│ 1   ┆ 7   │\n│ 2   ┆ 8   │\n│ 3   ┆ 9   │\n└─────┴─────┘", ">>> df.select(threshold=pl.when(pl.col(\"foo\") > 2).then(10).otherwise(0))\nshape: (3, 1)\n┌───────────┐\n│ threshold │\n│ ---       │\n│ i32       │\n╞═══════════╡\n│ 0         │\n│ 0         │\n│ 10        │\n└───────────┘"], "Parameters": [["*exprs", "Column(s) to select, specified as positional arguments.\nAccepts expression input. Strings are parsed as column names,\nother non-expression inputs are parsed as literals."], ["**named_exprs", "Additional columns to select, specified as keyword arguments.\nThe columns will be renamed to the keyword used."]], "Returns": [], "Category": ["Dataframe"], "index": 0}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.unique.html#polars.DataFrame.unique"], "Title": ["DataFrame.unique"], "Feature": ["DataFrame.unique"], "Description": ["Drop duplicate rows from this dataframe."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3, 1],\n...         \"bar\": [\"a\", \"a\", \"a\", \"a\"],\n...         \"ham\": [\"b\", \"b\", \"b\", \"b\"],\n...     }\n... )\n>>> df.unique(maintain_order=True)\nshape: (3, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ str ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ a   ┆ b   │\n│ 2   ┆ a   ┆ b   │\n│ 3   ┆ a   ┆ b   │\n└─────┴─────┴─────┘\n>>> df.unique(subset=[\"bar\", \"ham\"], maintain_order=True)\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ str ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ a   ┆ b   │\n└─────┴─────┴─────┘\n>>> df.unique(keep=\"last\", maintain_order=True)\nshape: (3, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ str ┆ str │\n╞═════╪═════╪═════╡\n│ 2   ┆ a   ┆ b   │\n│ 3   ┆ a   ┆ b   │\n│ 1   ┆ a   ┆ b   │\n└─────┴─────┴─────┘"], "Parameters": [["subset", "Column name(s) or selector(s), to consider when identifying\nduplicate rows. If set to None (default), use all columns."], ["keep {‘first’, ‘last’, ‘any’, ‘none’}", "Which of the duplicate rows to keep. ‘any’: Does not give any guarantee of which row is kept. This allows more optimizations. ‘none’: Don’t keep duplicate rows. ‘first’: Keep first unique row. ‘last’: Keep last unique row."], ["‘any’: Does not give any guarantee of which row is kept.", "This allows more optimizations."], ["maintain_order", "Keep the same order as the original DataFrame. This is more expensive to\ncompute.\nSettings this to True blocks the possibility\nto run on the streaming engine."]], "Returns": [["DataFrame", "DataFrame with unique rows."]], "Category": ["Dataframe"], "index": 1}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.join.html#polars.DataFrame.join"], "Title": ["DataFrame.join"], "Feature": ["DataFrame.join"], "Description": ["Join in SQL-like fashion."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n>>> other_df = pl.DataFrame(\n...     {\n...         \"apple\": [\"x\", \"y\", \"z\"],\n...         \"ham\": [\"a\", \"b\", \"d\"],\n...     }\n... )\n>>> df.join(other_df, on=\"ham\")\nshape: (2, 4)\n┌─────┬─────┬─────┬───────┐\n│ foo ┆ bar ┆ ham ┆ apple │\n│ --- ┆ --- ┆ --- ┆ ---   │\n│ i64 ┆ f64 ┆ str ┆ str   │\n╞═════╪═════╪═════╪═══════╡\n│ 1   ┆ 6.0 ┆ a   ┆ x     │\n│ 2   ┆ 7.0 ┆ b   ┆ y     │\n└─────┴─────┴─────┴───────┘", ">>> df.join(other_df, on=\"ham\", how=\"full\")\nshape: (4, 5)\n┌──────┬──────┬──────┬───────┬───────────┐\n│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_right │\n│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---       │\n│ i64  ┆ f64  ┆ str  ┆ str   ┆ str       │\n╞══════╪══════╪══════╪═══════╪═══════════╡\n│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a         │\n│ 2    ┆ 7.0  ┆ b    ┆ y     ┆ b         │\n│ null ┆ null ┆ null ┆ z     ┆ d         │\n│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null      │\n└──────┴──────┴──────┴───────┴───────────┘", ">>> df.join(other_df, on=\"ham\", how=\"full\", coalesce=True)\nshape: (4, 4)\n┌──────┬──────┬─────┬───────┐\n│ foo  ┆ bar  ┆ ham ┆ apple │\n│ ---  ┆ ---  ┆ --- ┆ ---   │\n│ i64  ┆ f64  ┆ str ┆ str   │\n╞══════╪══════╪═════╪═══════╡\n│ 1    ┆ 6.0  ┆ a   ┆ x     │\n│ 2    ┆ 7.0  ┆ b   ┆ y     │\n│ null ┆ null ┆ d   ┆ z     │\n│ 3    ┆ 8.0  ┆ c   ┆ null  │\n└──────┴──────┴─────┴───────┘", ">>> df.join(other_df, on=\"ham\", how=\"left\")\nshape: (3, 4)\n┌─────┬─────┬─────┬───────┐\n│ foo ┆ bar ┆ ham ┆ apple │\n│ --- ┆ --- ┆ --- ┆ ---   │\n│ i64 ┆ f64 ┆ str ┆ str   │\n╞═════╪═════╪═════╪═══════╡\n│ 1   ┆ 6.0 ┆ a   ┆ x     │\n│ 2   ┆ 7.0 ┆ b   ┆ y     │\n│ 3   ┆ 8.0 ┆ c   ┆ null  │\n└─────┴─────┴─────┴───────┘", ">>> df.join(other_df, on=\"ham\", how=\"semi\")\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ f64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6.0 ┆ a   │\n│ 2   ┆ 7.0 ┆ b   │\n└─────┴─────┴─────┘", ">>> df.join(other_df, on=\"ham\", how=\"anti\")\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ f64 ┆ str │\n╞═════╪═════╪═════╡\n│ 3   ┆ 8.0 ┆ c   │\n└─────┴─────┴─────┘", ">>> df.join(other_df, how=\"cross\")\nshape: (9, 5)\n┌─────┬─────┬─────┬───────┬───────────┐\n│ foo ┆ bar ┆ ham ┆ apple ┆ ham_right │\n│ --- ┆ --- ┆ --- ┆ ---   ┆ ---       │\n│ i64 ┆ f64 ┆ str ┆ str   ┆ str       │\n╞═════╪═════╪═════╪═══════╪═══════════╡\n│ 1   ┆ 6.0 ┆ a   ┆ x     ┆ a         │\n│ 1   ┆ 6.0 ┆ a   ┆ y     ┆ b         │\n│ 1   ┆ 6.0 ┆ a   ┆ z     ┆ d         │\n│ 2   ┆ 7.0 ┆ b   ┆ x     ┆ a         │\n│ 2   ┆ 7.0 ┆ b   ┆ y     ┆ b         │\n│ 2   ┆ 7.0 ┆ b   ┆ z     ┆ d         │\n│ 3   ┆ 8.0 ┆ c   ┆ x     ┆ a         │\n│ 3   ┆ 8.0 ┆ c   ┆ y     ┆ b         │\n│ 3   ┆ 8.0 ┆ c   ┆ z     ┆ d         │\n└─────┴─────┴─────┴───────┴───────────┘"], "Parameters": [["other", "DataFrame to join with."], ["on", "Name(s) of the join columns in both DataFrames. If set, left_on and right_on should be None. This should not be specified if how='cross' ."], ["how {‘inner’, ‘left’, ‘right’, ‘full’, ‘semi’, ‘anti’, ‘cross’}", "Join strategy. inner (Default) Returns rows that have matching values in both tables. left Returns all rows from the left table, and the matched rows from\nthe right table. full Returns all rows when there is a match in either left or right. cross Returns the Cartesian product of rows from both tables semi Returns rows from the left table that have a match in the right\ntable. anti Returns rows from the left table that have no match in the right\ntable."], ["left_on", "Name(s) of the left join column(s)."], ["right_on", "Name(s) of the right join column(s)."], ["suffix", "Suffix to append to columns with a duplicate name."], ["validate: {‘m:m’, ‘m:1’, ‘1:m’, ‘1:1’}", "Checks if join is of specified type. m:m (Default) Many-to-many (default). Does not result in checks. 1:1 One-to-one. Checks if join keys are unique in both left and\nright datasets. 1:m One-to-many. Checks if join keys are unique in left dataset. m:1 Many-to-one. Check if join keys are unique in right dataset. Note This is currently not supported by the streaming engine."], ["nulls_equal", "Join on null values. By default null values will never produce matches."], ["coalesce", "Coalescing behavior (merging of join columns). None (Default) Coalesce unless how='full' is specified. True Always coalesce join columns. False Never coalesce join columns. Note Joining on any other expressions than col will turn off coalescing."], ["maintain_order {‘none’, ‘left’, ‘right’, ‘left_right’, ‘right_left’}", "Which DataFrame row order to preserve, if any.\nDo not rely on any observed ordering without explicitly setting this\nparameter, as your code may break in a future release.\nNot specifying any ordering can improve performance.\nSupported for inner, left, right and full joins none (Default) No specific ordering is desired. The ordering might\ndiffer across Polars versions or even between different runs. left Preserves the order of the left DataFrame. right Preserves the order of the right DataFrame. left_right First preserves the order of the left DataFrame, then the right. right_left First preserves the order of the right DataFrame, then the left."]], "Returns": [], "Category": ["Dataframe"], "index": 2}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter"], "Title": ["DataFrame.filter"], "Feature": ["DataFrame.filter"], "Description": ["Filter rows, retaining those that match the given predicate expression(s)."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3, None, 4, None, 0],\n...         \"bar\": [6, 7, 8, None, None, 9, 0],\n...         \"ham\": [\"a\", \"b\", \"c\", None, \"d\", \"e\", \"f\"],\n...     }\n... )", ">>> df.filter(pl.col(\"foo\") > 1)\nshape: (3, 3)\n┌─────┬──────┬─────┐\n│ foo ┆ bar  ┆ ham │\n│ --- ┆ ---  ┆ --- │\n│ i64 ┆ i64  ┆ str │\n╞═════╪══════╪═════╡\n│ 2   ┆ 7    ┆ b   │\n│ 3   ┆ 8    ┆ c   │\n│ 4   ┆ null ┆ d   │\n└─────┴──────┴─────┘", ">>> df.filter(\n...     (pl.col(\"foo\") < 3) & (pl.col(\"ham\") == \"a\"),\n... )\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6   ┆ a   │\n└─────┴─────┴─────┘", ">>> df.filter(\n...     (pl.col(\"foo\") == 1) | (pl.col(\"ham\") == \"c\"),\n... )\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6   ┆ a   │\n│ 3   ┆ 8   ┆ c   │\n└─────┴─────┴─────┘", ">>> df.filter(\n...     pl.col(\"foo\") <= 2,\n...     ~pl.col(\"ham\").is_in([\"b\", \"c\"]),\n... )\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6   ┆ a   │\n│ 0   ┆ 0   ┆ f   │\n└─────┴─────┴─────┘", ">>> df.filter(foo=2, ham=\"b\")\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 2   ┆ 7   ┆ b   │\n└─────┴─────┴─────┘", ">>> df.filter(\n...     pl.col(\"foo\") == pl.col(\"bar\"),\n... )\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 0   ┆ 0   ┆ f   │\n└─────┴─────┴─────┘", ">>> df.filter(\n...     pl.col(\"foo\") != pl.col(\"bar\"),\n... )\nshape: (3, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6   ┆ a   │\n│ 2   ┆ 7   ┆ b   │\n│ 3   ┆ 8   ┆ c   │\n└─────┴─────┴─────┘", ">>> df.filter(\n...     pl.col(\"foo\").ne_missing(pl.col(\"bar\")),\n... )\nshape: (5, 3)\n┌──────┬──────┬─────┐\n│ foo  ┆ bar  ┆ ham │\n│ ---  ┆ ---  ┆ --- │\n│ i64  ┆ i64  ┆ str │\n╞══════╪══════╪═════╡\n│ 1    ┆ 6    ┆ a   │\n│ 2    ┆ 7    ┆ b   │\n│ 3    ┆ 8    ┆ c   │\n│ 4    ┆ null ┆ d   │\n│ null ┆ 9    ┆ e   │\n└──────┴──────┴─────┘"], "Parameters": [["predicates", "Expression(s) that evaluate to a boolean Series."], ["constraints", "Column filters; use name = value to filter columns by the supplied value.\nEach constraint will behave the same as pl.col(name).eq(value) , and\nbe implicitly joined with the other filter conditions using & ."]], "Returns": [], "Category": ["Dataframe"], "index": 3}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.group_by.html#polars.DataFrame.group_by"], "Title": ["DataFrame.group_by"], "Feature": ["DataFrame.group_by"], "Description": ["Start a group by operation."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n>>> df.group_by(\"a\").agg(pl.col(\"b\").sum())  \nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ str ┆ i64 │\n╞═════╪═════╡\n│ a   ┆ 2   │\n│ b   ┆ 5   │\n│ c   ┆ 3   │\n└─────┴─────┘", ">>> df.group_by(\"a\", maintain_order=True).agg(pl.col(\"c\"))\nshape: (3, 2)\n┌─────┬───────────┐\n│ a   ┆ c         │\n│ --- ┆ ---       │\n│ str ┆ list[i64] │\n╞═════╪═══════════╡\n│ a   ┆ [5, 3]    │\n│ b   ┆ [4, 2]    │\n│ c   ┆ [1]       │\n└─────┴───────────┘", ">>> df.group_by([\"a\", \"b\"]).agg(pl.max(\"c\"))  \nshape: (4, 3)\n┌─────┬─────┬─────┐\n│ a   ┆ b   ┆ c   │\n│ --- ┆ --- ┆ --- │\n│ str ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╡\n│ a   ┆ 1   ┆ 5   │\n│ b   ┆ 2   ┆ 4   │\n│ b   ┆ 3   ┆ 2   │\n│ c   ┆ 3   ┆ 1   │\n└─────┴─────┴─────┘", ">>> df.group_by(\"a\", pl.col(\"b\") // 2).agg(pl.col(\"c\").mean())  \nshape: (3, 3)\n┌─────┬─────┬─────┐\n│ a   ┆ b   ┆ c   │\n│ --- ┆ --- ┆ --- │\n│ str ┆ i64 ┆ f64 │\n╞═════╪═════╪═════╡\n│ a   ┆ 0   ┆ 4.0 │\n│ b   ┆ 1   ┆ 3.0 │\n│ c   ┆ 1   ┆ 1.0 │\n└─────┴─────┴─────┘", ">>> for name, data in df.group_by(\"a\"):  \n...     print(name)\n...     print(data)\n('a',)\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ a   ┆ b   ┆ c   │\n│ --- ┆ --- ┆ --- │\n│ str ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╡\n│ a   ┆ 1   ┆ 5   │\n│ a   ┆ 1   ┆ 3   │\n└─────┴─────┴─────┘\n('b',)\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ a   ┆ b   ┆ c   │\n│ --- ┆ --- ┆ --- │\n│ str ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╡\n│ b   ┆ 2   ┆ 4   │\n│ b   ┆ 3   ┆ 2   │\n└─────┴─────┴─────┘\n('c',)\nshape: (1, 3)\n┌─────┬─────┬─────┐\n│ a   ┆ b   ┆ c   │\n│ --- ┆ --- ┆ --- │\n│ str ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╡\n│ c   ┆ 3   ┆ 1   │\n└─────┴─────┴─────┘"], "Parameters": [["*by", "Column(s) to group by. Accepts expression input. Strings are parsed as\ncolumn names."], ["maintain_order", "Ensure that the order of the groups is consistent with the input data.\nThis is slower than a default group by.\nSettings this to True blocks the possibility\nto run on the streaming engine. Note Within each group, the order of rows is always preserved, regardless\nof this argument."], ["**named_by", "Additional columns to group by, specified as keyword arguments.\nThe columns will be renamed to the keyword used."]], "Returns": [["GroupBy", "Object which can be used to perform aggregations."]], "Category": ["Dataframe"], "index": 4}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.sort.html#polars.DataFrame.sort"], "Title": ["DataFrame.sort"], "Feature": ["DataFrame.sort"], "Description": ["Sort the dataframe by the given columns."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, None],\n...         \"b\": [6.0, 5.0, 4.0],\n...         \"c\": [\"a\", \"c\", \"b\"],\n...     }\n... )\n>>> df.sort(\"a\")\nshape: (3, 3)\n┌──────┬─────┬─────┐\n│ a    ┆ b   ┆ c   │\n│ ---  ┆ --- ┆ --- │\n│ i64  ┆ f64 ┆ str │\n╞══════╪═════╪═════╡\n│ null ┆ 4.0 ┆ b   │\n│ 1    ┆ 6.0 ┆ a   │\n│ 2    ┆ 5.0 ┆ c   │\n└──────┴─────┴─────┘", ">>> df.sort(pl.col(\"a\") + pl.col(\"b\") * 2, nulls_last=True)\nshape: (3, 3)\n┌──────┬─────┬─────┐\n│ a    ┆ b   ┆ c   │\n│ ---  ┆ --- ┆ --- │\n│ i64  ┆ f64 ┆ str │\n╞══════╪═════╪═════╡\n│ 2    ┆ 5.0 ┆ c   │\n│ 1    ┆ 6.0 ┆ a   │\n│ null ┆ 4.0 ┆ b   │\n└──────┴─────┴─────┘", ">>> df.sort([\"c\", \"a\"], descending=True)\nshape: (3, 3)\n┌──────┬─────┬─────┐\n│ a    ┆ b   ┆ c   │\n│ ---  ┆ --- ┆ --- │\n│ i64  ┆ f64 ┆ str │\n╞══════╪═════╪═════╡\n│ 2    ┆ 5.0 ┆ c   │\n│ null ┆ 4.0 ┆ b   │\n│ 1    ┆ 6.0 ┆ a   │\n└──────┴─────┴─────┘", ">>> df.sort(\"c\", \"a\", descending=[False, True])\nshape: (3, 3)\n┌──────┬─────┬─────┐\n│ a    ┆ b   ┆ c   │\n│ ---  ┆ --- ┆ --- │\n│ i64  ┆ f64 ┆ str │\n╞══════╪═════╪═════╡\n│ 1    ┆ 6.0 ┆ a   │\n│ null ┆ 4.0 ┆ b   │\n│ 2    ┆ 5.0 ┆ c   │\n└──────┴─────┴─────┘"], "Parameters": [["by", "Column(s) to sort by. Accepts expression input, including selectors. Strings\nare parsed as column names."], ["*more_by", "Additional columns to sort by, specified as positional arguments."], ["descending", "Sort in descending order. When sorting by multiple columns, can be specified\nper column by passing a sequence of booleans."], ["nulls_last", "Place null values last; can specify a single boolean applying to all columns\nor a sequence of booleans for per-column control."], ["multithreaded", "Sort using multiple threads."], ["maintain_order", "Whether the order should be maintained if elements are equal."]], "Returns": [], "Category": ["Dataframe"], "index": 5}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.limit.html#polars.DataFrame.limit"], "Title": ["DataFrame.limit"], "Feature": ["DataFrame.limit"], "Description": ["Get the firstnrows."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3, 4, 5],\n...         \"bar\": [6, 7, 8, 9, 10],\n...         \"ham\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n>>> df.limit(3)\nshape: (3, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ str │\n╞═════╪═════╪═════╡\n│ 1   ┆ 6   ┆ a   │\n│ 2   ┆ 7   ┆ b   │\n│ 3   ┆ 8   ┆ c   │\n└─────┴─────┴─────┘"], "Parameters": [["n", "Number of rows to return. If a negative value is passed, return all rows\nexcept the last abs(n) ."]], "Returns": [], "Category": ["Dataframe"], "index": 6}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.slice.html#polars.DataFrame.slice"], "Title": ["DataFrame.slice"], "Feature": ["DataFrame.slice"], "Description": ["Get a slice of this DataFrame."], "Examples": [">>> df = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n>>> df.slice(1, 2)\nshape: (2, 3)\n┌─────┬─────┬─────┐\n│ foo ┆ bar ┆ ham │\n│ --- ┆ --- ┆ --- │\n│ i64 ┆ f64 ┆ str │\n╞═════╪═════╪═════╡\n│ 2   ┆ 7.0 ┆ b   │\n│ 3   ┆ 8.0 ┆ c   │\n└─────┴─────┴─────┘"], "Parameters": [["offset", "Start index. Negative indexing is supported."], ["length", "Length of the slice. If set to None , all rows starting at the offset\nwill be selected."]], "Returns": [], "Category": ["Dataframe"], "index": 7}
{"HTML": ["https://docs.pola.rs/api/python/stable/reference/api/polars.union.html"], "Title": ["polars.union"], "Feature": ["polars.union"], "Description": ["Combine multiple DataFrames, LazyFrames, or Series into a single object."], "Examples": ["df1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\ndf2 = pl.DataFrame({\"a\": [2], \"b\": [4]})\npl.union([df1, df2])  # default is 'vertical' strategy\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ i64 │\n╞═════╪═════╡\n│ 1   ┆ 3   │\n│ 2   ┆ 4   │\n└─────┴─────┘\ndf1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\ndf2 = pl.DataFrame({\"a\": [2.5], \"b\": [4]})\npl.union([df1, df2], how=\"vertical_relaxed\")  # 'a' coerced into f64\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ f64 ┆ i64 │\n╞═════╪═════╡\n│ 1.0 ┆ 3   │\n│ 2.5 ┆ 4   │\n└─────┴─────┘\ndf_h1 = pl.DataFrame({\"l1\": [1, 2], \"l2\": [3, 4]})\ndf_h2 = pl.DataFrame({\"r1\": [5, 6], \"r2\": [7, 8], \"r3\": [9, 10]})\npl.union([df_h1, df_h2], how=\"horizontal\")\nshape: (2, 5)\n┌─────┬─────┬─────┬─────┬─────┐\n│ l1  ┆ l2  ┆ r1  ┆ r2  ┆ r3  │\n│ --- ┆ --- ┆ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ i64 ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╪═════╪═════╡\n│ 1   ┆ 3   ┆ 5   ┆ 7   ┆ 9   │\n│ 2   ┆ 4   ┆ 6   ┆ 8   ┆ 10  │\n└─────┴─────┴─────┴─────┴─────┘\nThe “diagonal” strategy allows for some frames to have missing columns, the values for which are filled with null:\ndf_d1 = pl.DataFrame({\"a\": [1], \"b\": [3]})\ndf_d2 = pl.DataFrame({\"a\": [2], \"c\": [4]})\npl.union([df_d1, df_d2], how=\"diagonal\")\nshape: (2, 3)\n┌─────┬──────┬──────┐\n│ a   ┆ b    ┆ c    │\n│ --- ┆ ---  ┆ ---  │\n│ i64 ┆ i64  ┆ i64  │\n╞═════╪══════╪══════╡\n│ 1   ┆ 3    ┆ null │\n│ 2   ┆ null ┆ 4    │\n└─────┴──────┴──────┘\nThe “align” strategies require at least one common column to align on:\ndf_a1 = pl.DataFrame({\"id\": [1, 2], \"x\": [3, 4]})\ndf_a2 = pl.DataFrame({\"id\": [2, 3], \"y\": [5, 6]})\ndf_a3 = pl.DataFrame({\"id\": [1, 3], \"z\": [7, 8]})\npl.union([df_a1, df_a2, df_a3], how=\"align\")  # equivalent to \"align_full\"\nshape: (3, 4)\n┌─────┬──────┬──────┬──────┐\n│ id  ┆ x    ┆ y    ┆ z    │\n│ --- ┆ ---  ┆ ---  ┆ ---  │\n│ i64 ┆ i64  ┆ i64  ┆ i64  │\n╞═════╪══════╪══════╪══════╡\n│ 1   ┆ 3    ┆ null ┆ 7    │\n│ 2   ┆ 4    ┆ 5    ┆ null │\n│ 3   ┆ null ┆ 6    ┆ 8    │\n└─────┴──────┴──────┴──────┘\npl.union([df_a1, df_a2, df_a3], how=\"align_left\")\nshape: (2, 4)\n┌─────┬─────┬──────┬──────┐\n│ id  ┆ x   ┆ y    ┆ z    │\n│ --- ┆ --- ┆ ---  ┆ ---  │\n│ i64 ┆ i64 ┆ i64  ┆ i64  │\n╞═════╪═════╪══════╪══════╡\n│ 1   ┆ 3   ┆ null ┆ 7    │\n│ 2   ┆ 4   ┆ 5    ┆ null │\n└─────┴─────┴──────┴──────┘\npl.union([df_a1, df_a2, df_a3], how=\"align_right\")\nshape: (2, 4)\n┌─────┬──────┬──────┬─────┐\n│ id  ┆ x    ┆ y    ┆ z   │\n│ --- ┆ ---  ┆ ---  ┆ --- │\n│ i64 ┆ i64  ┆ i64  ┆ i64 │\n╞═════╪══════╪══════╪═════╡\n│ 1   ┆ null ┆ null ┆ 7   │\n│ 3   ┆ null ┆ 6    ┆ 8   │\n└─────┴──────┴──────┴─────┘\npl.union([df_a1, df_a2, df_a3], how=\"align_inner\")\nshape: (0, 4)\n┌─────┬─────┬─────┬─────┐\n│ id  ┆ x   ┆ y   ┆ z   │\n│ --- ┆ --- ┆ --- ┆ --- │\n│ i64 ┆ i64 ┆ i64 ┆ i64 │\n╞═════╪═════╪═════╪═════╡\n└─────┴─────┴─────┴─────┘"], "Parameters": [["items", "DataFrames, LazyFrames, or Series to concatenate."], ["how:{‘vertical’, ‘vertical_relaxed’, ‘diagonal’, ‘diagonal_relaxed’, ‘horizontal’, ‘align’, ‘align_full’, ‘align_inner’, ‘align_left’, ‘align_right’}", "Note that Series only support the vertical strategy.\n\nvertical: Applies multiple vstack operations.\n\nvertical_relaxed: Same as vertical, but additionally coerces columns to their common supertype if they are mismatched (eg: Int32 → Int64).\n\ndiagonal: Finds a union between the column schemas and fills missing column values with null.\n\ndiagonal_relaxed: Same as diagonal, but additionally coerces columns to their common supertype if they are mismatched (eg: Int32 → Int64).\n\nhorizontal: Stacks Series from DataFrames horizontally and fills with null if the lengths don’t match.\n\nalign, align_full, align_left, align_right: Combines frames horizontally, auto-determining the common key columns and aligning rows using the same logic as align_frames (note that “align” is an alias for “align_full”). The “align” strategy determines the type of join used to align the frames, equivalent to the “how” parameter on align_frames. Note that the common join columns are automatically coalesced, but other column collisions will raise an error (if you need more control over this you should use a suitable join method directly)."],["strict","When how=`horizontal`, require all DataFrames to be the same height, raising an error if not."]], ",Returns": [], "Category": ["Functions"], "index": 8}
